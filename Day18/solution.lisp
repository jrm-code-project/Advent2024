;;; -*- Lisp -*-

(in-package "ADVENT2024/DAY18")

(defun read-input (file grid n-bytes)
  (iterate ((coord (#M(lambda (line)
                       (apply #'coord (map 'list #'parse-integer (str:split #\, line))))
                      (cotruncate (scan-file file #'read-line)
                                  (scan-range :below n-bytes)))))
    (setf (grid-ref grid coord) '|#|))
  (setf (grid-ref grid (coord 0 0)) '|S|)
  (setf (grid-ref grid (coord (1- (grid-height grid)) (1- (grid-width grid)))) '|E|))

(defun sample-input ()
  (let ((grid (make-grid 7 7 :initial-element '|.|)))
    (read-input (sample-input-pathname) grid 12)
    grid))

(defun input (nbytes)
  (let ((grid (make-grid 71 71 :initial-element '|.|)))
    (read-input (input-pathname) grid nbytes)
    grid))

(defun start-and-goal (maze)
  (let ((inverse (invert-grid maze '|.|)))
    (values (first (gethash 'S inverse))
            (first (gethash 'E inverse)))))

(defun show-maze (maze &optional highlight)
  (format t "~&")
  (dotimes (row (grid-height maze))
    (format t "~%")
    (dotimes (col (grid-width maze))
      (cond ((eql (grid-ref maze (coord col row)) '\#)
             (format t "#"))
            ((member (coord col row) highlight :test #'equal)
             (format t "O"))
            ((eql (grid-ref maze (coord col row)) '|S|)
             (format t "S"))
            ((eql (grid-ref maze (coord col row)) '|E|)
             (format t "E"))
            ((eql (grid-ref maze (coord col row)) '+)
             (format t "+"))
            (t
             (format t "."))))))

(defun dead-end? (maze coord)
  (and (on-grid? maze coord)
       (eql (grid-ref maze coord) '|.|)
       (let ((n (coord-north coord))
             (s (coord-south coord))
             (e (coord-east coord))
             (w (coord-west coord)))
         (let ((n* (or (not (on-grid? maze n))
                       (eql (grid-ref maze n) '\#)))
               (s* (or (not (on-grid? maze s))
                       (eql (grid-ref maze s) '\#)))
               (e* (or (not (on-grid? maze e))
                       (eql (grid-ref maze e) '\#)))
               (w* (or (not (on-grid? maze w))
                       (eql (grid-ref maze w) '\#))))
           (or (and n* e* w*)
               (and e* n* s*)
               (and s* e* w*)
               (and w* n* s*))))))

(defun flood-dead-end! (maze coord)
  (when (dead-end? maze coord)
    (setf (grid-ref maze coord) '\#)
    (flood-dead-end! maze (coord-north coord))
    (flood-dead-end! maze (coord-south coord))
    (flood-dead-end! maze (coord-east coord))
    (flood-dead-end! maze (coord-west coord))))

(defun flood-dead-ends! (maze)
  (iterate ((coord (scan-grid-coords maze)))
    (flood-dead-end! maze coord)))

(defun vertex? (maze coord)
  (and (on-grid? maze coord)
       (eql (grid-ref maze coord) '|.|)
       (let ((n (coord-north coord))
             (s (coord-south coord))
             (e (coord-east coord))
             (w (coord-west coord)))
         (let ((n* (and (on-grid? maze n) (member (grid-ref maze n) '(\. + S E))))
               (s* (and (on-grid? maze s) (member (grid-ref maze s) '(\. + S E))))
               (e* (and (on-grid? maze e) (member (grid-ref maze e) '(\. + S E))))
               (w* (and (on-grid? maze w) (member (grid-ref maze w) '(\. + S E)))))
           (or (and n* e* w*)
               (and e* n* s*)
               (and s* e* w*)
               (and w* n* s*))))))

(defun mark-vertices! (maze)
  (let ((vertices '()))
    (iterate ((coord (scan-grid-coords maze)))
      (when (vertex? maze coord)
        (setf (grid-ref maze coord) '+)
        (push coord vertices)))
    vertices))

(defun walk-edge (maze coord edge)
  (if (member (grid-ref maze coord) '(+ S E))
      (cons coord edge)
      (let ((n (coord-north coord))
            (s (coord-south coord))
            (e (coord-east coord))
            (w (coord-west coord)))
        (cond ((and (on-grid? maze n)
                    (not (equal n (first edge)))
                    (eql (grid-ref maze n) '|.|))
               (walk-edge maze n (cons coord edge)))
              ((and (on-grid? maze n)
                    (not (equal n (first edge)))
                    (member (grid-ref maze n) '(+ S E)))
               (list* n coord edge))
              ((and (on-grid? maze e)
                    (not (equal e (first edge)))
                    (eql (grid-ref maze e) '|.|))
               (walk-edge maze e (cons coord edge)))
              ((and (on-grid? maze e)
                    (not (equal e (first edge)))
                    (member (grid-ref maze e) '(+ S E)))
               (list* e coord edge))
              ((and (on-grid? maze s)
                    (not (equal s (first edge)))
                    (eql (grid-ref maze s) '|.|))
               (walk-edge maze s (cons coord edge)))
              ((and (on-grid? maze s)
                    (not (equal s (first edge)))
                    (member (grid-ref maze s) '(+ S E)))
               (list* s coord edge))
              ((and (on-grid? maze w)
                    (not (equal w (first edge)))
                    (eql (grid-ref maze w) '|.|))
               (walk-edge maze w (cons coord edge)))
              ((and (on-grid? maze w)
                    (not (equal w (first edge)))
                    (member (grid-ref maze w) '(+ S E)))
               (list* w coord edge))))))

(defun vertex-edges (maze vertex)
  (let ((n (coord-north vertex))
        (s (coord-south vertex))
        (e (coord-east vertex))
        (w (coord-west vertex))
        (edges '()))
    (when (and (on-grid? maze n) (member (grid-ref maze n) '(|.| + S E)))
      (push (walk-edge maze n (list vertex)) edges))
    (when (and (on-grid? maze s) (member (grid-ref maze s) '(|.| + S E)))
      (push (walk-edge maze s (list vertex)) edges))
    (when (and (on-grid? maze e) (member (grid-ref maze e) '(|.| + S E)))
      (push (walk-edge maze e (list vertex)) edges))
    (when (and (on-grid? maze w) (member (grid-ref maze w) '(|.| + S E)))
      (push (walk-edge maze w (list vertex)) edges))
    edges))

(defun score-coord-list (coord-list)
  (1- (length coord-list)))

(defun at-goal? (path goal)
  (equal (first (first path)) goal))

(defun path->coord-list (path)
  (if (null (rest path))
      (first path)
      (append (butlast (first path)) (path->coord-list (rest path)))))

(defun score-path (path)
  (score-coord-list (path->coord-list path)))

(defun path-extensions (maze path)
  (let* ((latest-edge (first path))
         (latest-vertex (first latest-edge))
         (back-edge (reverse latest-edge))
         (outgoing-edges (remove back-edge (vertex-edges maze latest-vertex) :test #'equal)))
    (map 'list (lambda (edge) (cons edge path)) outgoing-edges)))

(defun make-priority-queue ()
  wtree::empty)

(defun pq-insert (pq entry score)
  (let* ((probe (wtree::node/find #'< pq score)))
    (wtree::node/add #'< pq score (cons entry (and probe (wtree::node/v probe))))))

(defun pq-pop (pq)
  (let* ((node (wtree::node/min pq))
         (score (wtree::node/k node))
         (value-list (wtree::node/v node))
         (value (car value-list))
         (tail (cdr value-list)))
    (if (null tail)
        (values value score (wtree::node/delmin pq))
        (values value score (wtree::node/add #'< (wtree::node/delmin pq) score tail)))))

(defun solve-maze (maze)
  (flood-dead-ends! maze)
  (mark-vertices! maze)
  (multiple-value-bind (start goal)
      (start-and-goal maze)
    (let* ((visited-edges     (make-hash-table :test 'equal))
           (predecessor-edges (make-hash-table :test 'equal))
           ;; The initial edges are the ones that start at the start vertex.
           (initial-edges (vertex-edges maze start))
           ;; A path is a list of edges.  An initial path is a list of one edge starting at the start vertex.
           (initial-paths (map 'list #'list initial-edges)))

      (dolist (edge initial-edges)
        (setf (gethash edge visited-edges) (score-path (list edge))))

      ;; Main loop, iteratively extend the lowest scoring path.
      (let iter ((scored-paths (do ((pq (make-priority-queue) (pq-insert pq (car initial-paths) (score-path (car initial-paths))))
                                    (initial-paths initial-paths (cdr initial-paths)))
                                   ((null initial-paths) pq))))
                                        ;(show-maze maze)
        (unless (wtree::empty? scored-paths)
          (multiple-value-bind (path path-score next-scored-paths) (pq-pop scored-paths)
                                        ;(format t "~%path: ~{~&~S~%~}~%" path)
            (if (at-goal? path goal)
                ;; Reached the goal.  Keep popping until we have all solutions.
                (let solution-iter ((solutions (list path))
                                    (next-scored-paths next-scored-paths))
                  (if (wtree::empty? next-scored-paths)
                      solutions
                      (multiple-value-bind (other-path other-path-score next-scored-paths) (pq-pop next-scored-paths)
                        (if (= other-path-score path-score)
                            (solution-iter (if (at-goal? other-path goal)
                                               (cons other-path solutions)
                                               solutions)
                                           next-scored-paths)
                            (values solutions predecessor-edges)))))
                (let iter1 ((extensions (path-extensions maze path))
                            (next-scored-paths next-scored-paths))
                  (if (null extensions)
                      (iter next-scored-paths)
                      (let* ((extension (first extensions))
                             (extension-score (score-path extension))
                             (latest-edge (first extension))
                             (predecessor (second extension))
                             (prior-score (gethash latest-edge visited-edges)))
                        (cond ((null prior-score)
                               (setf (gethash latest-edge visited-edges) extension-score
                                     (gethash latest-edge predecessor-edges) (list predecessor))
                               (iter1 (rest extensions)
                                      (pq-insert next-scored-paths extension extension-score)))
                              ;; If we have found an extension with a worse score, we ignore it.
                              ((> extension-score prior-score)
                               (iter1 (rest extensions) next-scored-paths))
                              ;; If we have found an extension with an equal score, we add the predecessor,
                              ;; but do not pursue it further.
                              ((= extension-score prior-score)
                               (push predecessor (gethash latest-edge predecessor-edges))
                               (iter1 (rest extensions) next-scored-paths))
                              ;; If we have found an extension with a better score, we replace the prior extension.
                              ((< extension-score prior-score)
                               (setf (gethash latest-edge visited-edges) extension-score
                                     (gethash latest-edge predecessor-edges) (list predecessor))
                               (iter1 (rest extensions)
                                      (pq-insert next-scored-paths extension extension-score))))))))))))))

(defun test-1 ()
  (let* ((grid (sample-input))
         (solutions (solve-maze grid)))
    (score-path (car solutions))))

(defun part-1 ()
  (let* ((grid (input 1024))
         (solutions (solve-maze grid)))
    (score-path (car solutions))))

(defun total-walls ()
  (collect-length (scan-file (input-pathname) #'read-line)))

(defun binary-search (pass fail)
  (if (= (1+ pass) fail)
      (list pass fail)
      (let* ((mid (floor (+ pass fail) 2))
             (grid (input mid)))
        (let ((solutions (solve-maze grid)))
          (if (null solutions)
              (binary-search pass mid)
              (binary-search mid fail))))))

(defun get-coord (n)
  (collect-nth n (scan-file (input-pathname) #'read-line)))

(defun part-2 ()
  (collect-nth (car (binary-search 1024 (total-walls)))
    (scan-file (input-pathname) #'read-line)))

(defconstant +solution-1+ 280)
(alexandria:define-constant +solution-2+ "28,56" :test #'string=)
